/**
 * 設定
 */
const CONFIG = {
  API_KEY: 'YOUR_API_KEY_HERE',
  API_TOKEN: 'YOUR_API_TOKEN_HERE',
  BOARD_ID: 'YBjytWao',
  // ★ここに先ほど特定したIDを設定します
  CONSTRUCTION_NO_CUSTOM_FIELD_ID: '6799b710ccbdbe405066ba7d',

  SPREADSHEET_ID: '174jrPiJdKfT4DduOrHmOudvaznYws11wbn7nDhFHpt0',
  MEMBER_SHEET_NAME: 'メンバー設定',
  MEMO_SHEET_NAME: 'メモ',
  CARD_MEMO_SHEET_NAME: 'カードメモ',
  GAME_SHEET_NAME: 'GameData',
  LOG_SHEET_NAME: 'ログ'
};

function doGet() {
  return HtmlService.createTemplateFromFile('index').evaluate()
    .setTitle('わく☆とれ') // ★ここを変更しました
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

/**
 * データ取得のメイン関数（期限切れメモ検出機能＋カスタムフィールド同期）
 */
function getTrelloData() {
  try {
    const listsUrl = `https://api.trello.com/1/boards/${CONFIG.BOARD_ID}/lists?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}&filter=open`;
    const lists = fetchJson(listsUrl);

    // ▼▼▼ カスタムフィールド定義と「選択肢(options)」を取得 ▼▼▼
    const customFieldsUrl = `https://api.trello.com/1/boards/${CONFIG.BOARD_ID}/customFields?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}`;
    const customFieldsDef = fetchJson(customFieldsUrl);

    // 「構築No.」フィールドの定義を探す
    const constructionFieldDef = customFieldsDef.find(f => f.name === '構築No.');
    const constructionFieldId = constructionFieldDef ? constructionFieldDef.id : null;
    // ★重要：リスト形式の場合、選択肢の定義(options)も確保しておく
    const constructionFieldOptions = constructionFieldDef ? (constructionFieldDef.options || []) : [];
    // ▲▲▲ 追加ここまで ▲▲▲

    const cardsUrl = `https://api.trello.com/1/boards/${CONFIG.BOARD_ID}/cards?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}&fields=name,id,shortLink,shortUrl,idList,due,dueComplete,labels,desc&checklists=all&customFieldItems=true`;
    const cards = fetchJson(cardsUrl);

    const assignments = getAssignmentsFromSheet();
    const memberLists = getMembersFromSheet();

    // (期限切れメモ検出処理...省略せずにそのまま残す)
    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
    const memoSheet = ss.getSheetByName(CONFIG.CARD_MEMO_SHEET_NAME);
    const overdueCardIds = new Set();

    if (memoSheet && memoSheet.getLastRow() > 1) {
      const memoData = memoSheet.getRange(2, 1, memoSheet.getLastRow() - 1, 8).getValues();
      const now = new Date();
      memoData.forEach(row => {
        const deadlineStr = row[3];
        const cardId = String(row[5]).trim();
        const isFinished = String(row[7]).toUpperCase() === 'TRUE';
        if (cardId && !isFinished && deadlineStr) {
          const deadline = new Date(deadlineStr);
          if (deadline < now) overdueCardIds.add(cardId);
        }
      });
    }

    const industrySet = new Set();
    const prefectureSet = new Set();
    const trelloLabelSet = new Set();

    const rolesSet = {
      construction: new Set(),
      system: new Set(),
      sales: new Set(),
      mtg: new Set()
    };

    const systemTypeSet = new Set();

    const processedCards = cards.map(card => {
      const attributes = { industries: [], prefectures: [] };

      if (card.checklists) {
        card.checklists.forEach(checklist => {
          if (checklist.name === '業種') {
            checklist.checkItems.forEach(item => {
              if (item.state === 'complete') {
                attributes.industries.push(item.name);
                industrySet.add(item.name);
              }
            });
          } else if (checklist.name === '都道府県') {
            checklist.checkItems.forEach(item => {
              if (item.state === 'complete') {
                attributes.prefectures.push(item.name);
                prefectureSet.add(item.name);
              }
            });
          }
        });
      }

      const processedLabels = [];
      if (card.labels && card.labels.length > 0) {
        card.labels.forEach(label => {
          const labelName = label.name || "";
          if (labelName) trelloLabelSet.add(labelName);
          processedLabels.push({ name: labelName, color: label.color });
        });
      }

      let safeId = "";
      if (card.shortLink) safeId = String(card.shortLink);
      else if (card.shortUrl) {
        const parts = card.shortUrl.split('/');
        safeId = parts[parts.length - 1];
      } else {
        safeId = String(card.id);
      }
      safeId = safeId.trim();

      const roleData = assignments[safeId] || {
        construction: '', system: '', sales: '', mtg: '', updatedAt: '',
        systemType: '', systemType2: '',
        customLink: '',
        constructionNumber: '', memo1: '', memo2: '', memo3: '',
        isPinned: 'FALSE'
      };

      // ▼▼▼ 修正：Trelloのカスタムフィールド値を優先して上書きする処理（リスト対応版） ▼▼▼
      if (constructionFieldId && card.customFieldItems) {
        // このカードに設定されている「構築No.」のアイテムを探す
        const targetItem = card.customFieldItems.find(item => item.idCustomField === constructionFieldId);

        if (targetItem) {
          let trelloVal = "";

          // パターンA: リスト形式の場合 (idValueが入っている)
          if (targetItem.idValue) {
            // 定義(options)の中から、このIDに一致する選択肢を探して、そのテキスト(value.text)を取得
            const selectedOption = constructionFieldOptions.find(opt => opt.id === targetItem.idValue);
            if (selectedOption && selectedOption.value) {
              trelloVal = selectedOption.value.text;
            }
          }
          // パターンB: 数値・テキスト形式の場合 (valueが入っている)
          else if (targetItem.value) {
            if (targetItem.value.number !== undefined) {
              trelloVal = String(targetItem.value.number);
            } else if (targetItem.value.text !== undefined) {
              trelloVal = String(targetItem.value.text);
            }
          }

          // 値が取得できていれば、シートの値をTrelloの値で上書き表示する
          if (trelloVal !== "") {
            roleData.constructionNumber = trelloVal;
          }
        }
      }
      // ▲▲▲ 修正ここまで ▲▲▲

      if (roleData.construction) rolesSet.construction.add(roleData.construction);
      if (roleData.system) rolesSet.system.add(roleData.system);
      if (roleData.sales) rolesSet.sales.add(roleData.sales);
      if (roleData.mtg) rolesSet.mtg.add(roleData.mtg);
      if (roleData.systemType) systemTypeSet.add(roleData.systemType);
      if (roleData.systemType2) systemTypeSet.add(roleData.systemType2);

      return {
        id: safeId,
        realId: card.id,
        name: card.name,
        idList: card.idList,
        url: card.shortUrl,
        due: card.due,
        dueComplete: card.dueComplete,
        industries: attributes.industries,
        prefectures: attributes.prefectures,
        trelloLabels: processedLabels,
        roles: roleData,
        desc: card.desc || ""
      };
    });

    return {
      data: {
        lists: lists.map(l => ({ id: l.id, name: l.name })),
        cards: processedCards,
        members: memberLists,
        overdueMemoCardIds: Array.from(overdueCardIds),
        filterOptions: {
          industries: Array.from(industrySet).sort(),
          prefectures: Array.from(prefectureSet).sort(),
          trelloLabels: Array.from(trelloLabelSet).sort(),
          roles: {
            construction: Array.from(rolesSet.construction).sort(),
            system: Array.from(rolesSet.system).sort(),
            sales: Array.from(rolesSet.sales).sort(),
            mtg: Array.from(rolesSet.mtg).sort()
          },
          systemTypes: Array.from(systemTypeSet).sort()
        }
      },
      error: null
    };

  } catch (e) {
    Logger.log(`Error: ${e.message}`);
    return { data: null, error: 'データ取得エラー: ' + e.message };
  }
}

/**
 * ★機能追加：カード移動＆ログ記録
 * 引数に userId, cardName, listName を追加
 */
function moveCardTrello(cardId, newListId, userId, cardName, listName) {
  try {
    const url = `https://api.trello.com/1/cards/${cardId}?idList=${newListId}&key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}`;
    const options = {
      method: 'put',
      muteHttpExceptions: true
    };
    const response = UrlFetchApp.fetch(url, options);

    if (response.getResponseCode() !== 200) {
      throw new Error('Trello API Error: ' + response.getContentText());
    }

    // ★修正：第3引数に cardId を渡す
    saveLog(userId, `移動: ${cardName} -> ${listName}`, cardId);

    return { success: true };
  } catch (e) {
    return { success: false, error: e.message };
  }
}

/**
 * ★修正版：Trelloのカード期限(Due)を更新する
 * JSONペイロードではなく、URLパラメータで確実に更新・削除を行う
 */
function updateTrelloDue(cardId, dueString) {
  try {
    // 期限削除の場合は文字列の "null" を渡す必要があります（URLパラメータの場合）
    // 値がある場合はそのまま、ない場合(nullや空文字)は "null" 文字列にします
    const dueValue = (dueString && dueString !== "") ? dueString : "null";

    // URLのクエリパラメータとして due を設定します
    // これにより Trello API が確実に "削除" (null) または "更新" を認識します
    const url = `https://api.trello.com/1/cards/${cardId}?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}&due=${dueValue}`;

    const options = {
      method: 'put',
      muteHttpExceptions: true
    };

    // ペイロードは不要になったため削除し、URLのみでリクエストします
    const response = UrlFetchApp.fetch(url, options);

    if (response.getResponseCode() !== 200) {
      throw new Error('Trello Due Date Error: ' + response.getContentText());
    }
    return { success: true };
  } catch (e) {
    return { success: false, error: e.message };
  }
}

/**
 * ★機能追加：操作ログをシートに保存
 */
function saveLog(userId, action, cardId = "") {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
    let sheet = ss.getSheetByName(CONFIG.LOG_SHEET_NAME);
    if (!sheet) {
      sheet = ss.insertSheet(CONFIG.LOG_SHEET_NAME);
      // ヘッダーにCardIDを追加
      sheet.appendRow(['日時', 'ユーザーID', '操作内容', 'CardID']);
    }
    const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');
    // 4列目にカードIDを保存
    sheet.appendRow([now, userId, action, cardId]);
  } catch (e) {
    console.error("Log Error:" + e.message);
  }
}

/**
 * ★追加：特定のカードIDに関するログを取得する
 */
function getCardLogs(cardId) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  const sheet = ss.getSheetByName(CONFIG.LOG_SHEET_NAME);
  if (!sheet) return [];

  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return [];

  // 全データを取得
  const data = sheet.getRange(2, 1, lastRow - 1, 4).getValues();
  const targetId = String(cardId).trim();

  // カードIDが一致する行、または操作内容にカードIDが含まれている行（旧仕様互換のため）を抽出
  const logs = data.filter(row => {
    const logCardId = String(row[3] || "").trim();
    return logCardId === targetId;
  });

  // 新しい順にソートして返す
  logs.sort((a, b) => new Date(b[0]) - new Date(a[0]));

  return logs.map(row => ({
    date: row[0] ? Utilities.formatDate(new Date(row[0]), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm') : '',
    user: row[1],
    action: row[2]
  }));
}

function getMembersFromSheet() {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  const sheet = ss.getSheetByName(CONFIG.MEMBER_SHEET_NAME);

  const result = { construction: [], system: [], sales: [], mtg: [] };

  if (!sheet) return result;
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return result;

  const data = sheet.getRange(2, 1, lastRow - 1, 4).getValues();

  data.forEach(row => {
    if (row[0] && String(row[0]).trim() !== "") result.construction.push(String(row[0]).trim());
    if (row[1] && String(row[1]).trim() !== "") result.system.push(String(row[1]).trim());
    if (row[2] && String(row[2]).trim() !== "") result.sales.push(String(row[2]).trim());
    if (row[3] && String(row[3]).trim() !== "") result.mtg.push(String(row[3]).trim());
  });

  return result;
}

function getAssignmentsFromSheet() {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  const sheet = ss.getSheets()[0];
  const lastRow = sheet.getLastRow();

  if (lastRow <= 1) return {};

  const data = sheet.getRange(2, 1, lastRow - 1, 14).getDisplayValues();
  const map = {};

  data.forEach(row => {
    const idStr = String(row[0]).trim();
    if (idStr && idStr !== "") {
      map[idStr] = {
        construction: row[1] ? String(row[1]).trim() : '',
        system: row[2] ? String(row[2]).trim() : '',
        sales: row[3] ? String(row[3]).trim() : '',
        mtg: row[4] ? String(row[4]).trim() : '',
        updatedAt: row[5] ? String(row[5]).trim() : '',
        systemType: row[6] ? String(row[6]).trim() : '',
        customLink: row[7] ? String(row[7]).trim() : '',
        constructionNumber: row[8] ? String(row[8]).trim() : '',
        memo1: row[9] ? String(row[9]).trim() : '',
        memo2: row[10] ? String(row[10]).trim() : '',
        memo3: row[11] ? String(row[11]).trim() : '',
        systemType2: row[12] ? String(row[12]).trim() : '',
        isPinned: row[13] ? String(row[13]).trim() : 'FALSE'
      };
    }
  });

  return map;
}

function saveAssignments(cardId, rolesObj) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(10000);
    const targetId = String(cardId).trim();
    if (!targetId || targetId === "null" || targetId === "undefined" || targetId === "") {
      throw new Error(`保存エラー: IDが無効です(値: ${cardId})。画面を更新してください。`);
    }

    // ▼▼▼ 修正：Trelloの構築No.(リスト形式)を更新する処理 ▼▼▼
    if (CONFIG.CONSTRUCTION_NO_CUSTOM_FIELD_ID) {
      try {
        // リスト形式の選択肢と照合するため、数値ではなく文字列("1", "2"...)として渡します
        const constructionVal = rolesObj.constructionNumber ? String(rolesObj.constructionNumber) : null;
        updateTrelloListCustomField(targetId, CONFIG.CONSTRUCTION_NO_CUSTOM_FIELD_ID, constructionVal);
      } catch (trelloError) {
        Logger.log('Trello Update Error: ' + trelloError.message);
      }
    }
    // ▲▲▲ 修正ここまで ▲▲▲

    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
    const sheet = ss.getSheets()[0];

    sheet.getRange("A:A").setNumberFormat("@");

    const textFinder = sheet.getRange("A:A").createTextFinder(targetId).matchEntireCell(true);
    const foundRange = textFinder.findNext();

    const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm');

    const saveValues = [[
      rolesObj.construction,
      rolesObj.system,
      rolesObj.sales,
      rolesObj.mtg,
      now,
      rolesObj.systemType || '',
      rolesObj.customLink || '',
      rolesObj.constructionNumber || '',
      rolesObj.memo1 || '',
      rolesObj.memo2 || '',
      rolesObj.memo3 || '',
      rolesObj.systemType2 || '',
      rolesObj.isPinned || 'FALSE'
    ]];

    if (foundRange) {
      const rowNum = foundRange.getRow();
      sheet.getRange(rowNum, 2, 1, 13).setValues(saveValues);
    } else {
      sheet.appendRow([
        targetId,
        rolesObj.construction,
        rolesObj.system,
        rolesObj.sales,
        rolesObj.mtg,
        now,
        rolesObj.systemType || '',
        rolesObj.customLink || '',
        rolesObj.constructionNumber || '',
        rolesObj.memo1 || '',
        rolesObj.memo2 || '',
        rolesObj.memo3 || '',
        rolesObj.systemType2 || '',
        rolesObj.isPinned || 'FALSE'
      ]);
    }
    return true;

  } catch (e) {
    Logger.log('Save Error: ' + e.message);
    throw e;
  } finally {
    lock.releaseLock();
  }
}

function saveBulkAssignments(assignmentsArray) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(20000);

    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
    const sheet = ss.getSheets()[0];
    const lastRow = sheet.getLastRow();

    const idMap = new Map();
    if (lastRow > 1) {
      const idValues = sheet.getRange(2, 1, lastRow - 1, 1).getValues();
      idValues.forEach((row, index) => {
        idMap.set(String(row[0]).trim(), index + 2);
      });
    }

    const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm');
    const updates = [];
    const newRows = [];

    assignmentsArray.forEach(item => {
      const targetId = String(item.id).trim();
      const roles = item.roles;

      const rowValues = [
        roles.construction,
        roles.system,
        roles.sales,
        roles.mtg,
        now,
        roles.systemType || '',
        roles.customLink || '',
        roles.constructionNumber || '',
        roles.memo1 || '',
        roles.memo2 || '',
        roles.memo3 || '',
        roles.systemType2 || '',
        roles.isPinned || 'FALSE'
      ];

      if (idMap.has(targetId)) {
        updates.push({
          row: idMap.get(targetId),
          values: [rowValues]
        });
      } else {
        newRows.push([targetId, ...rowValues]);
      }
    });

    updates.forEach(u => {
      sheet.getRange(u.row, 2, 1, 13).setValues(u.values);
    });

    if (newRows.length > 0) {
      const startRow = sheet.getLastRow() + 1;
      sheet.getRange(startRow, 1, newRows.length, 14).setValues(newRows);
    }

    return true;

  } catch (e) {
    Logger.log('Bulk Save Error: ' + e.message);
    throw e;
  } finally {
    lock.releaseLock();
  }
}

/**
 * データ取得用関数（リトライ機能強化版）
 * 429エラー時に指数バックオフで再試行します
 */
function fetchJson(url) {
  const MAX_RETRIES = 5; // 最大リトライ回数
  let lastError = null;

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    const options = { muteHttpExceptions: true };
    let response;

    try {
      response = UrlFetchApp.fetch(url, options);
    } catch (e) {
      // ネットワークエラー等の一時的な接続不良の場合も少し待ってリトライ
      console.warn(`Fetch connection error (Attempt ${attempt + 1}): ${e.message}`);
      Utilities.sleep(2000);
      continue;
    }

    const code = response.getResponseCode();

    if (code === 200) {
      return JSON.parse(response.getContentText());
    }

    if (code === 429) {
      // 429 (Too Many Requests) の場合
      // 待機時間を指数的に増やす (例: 2秒, 4秒, 8秒, 16秒...) + ランダムな揺らぎ(Jitter)
      const sleepTime = Math.pow(2, attempt + 1) * 1000 + (Math.floor(Math.random() * 1000));
      console.warn(`API Error 429 detected. Retrying in ${sleepTime}ms... (Attempt ${attempt + 1}/${MAX_RETRIES})`);
      Utilities.sleep(sleepTime);
      lastError = `API Error 429: Trelloのアクセス制限により取得できませんでした。時間をおいて再読込してください。`;
      continue;
    }

    // 429以外のエラー（401認証エラーなど）は即座に例外を投げる
    throw new Error(`API Error ${code}: ${response.getContentText()}`);
  }

  // リトライ回数を使い果たした場合
  throw new Error(lastError || 'API Retry limit exceeded');
}

/* =========================================
   メモ帳機能（修正版：共有メモ保護）
   ========================================= */

/**
 * ★修正：個人メモ取得（判定強化版）
 * ・TRUE/true/論理値のどれでも完了とみなすように修正
 */
function getMemos(userId) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  let sheet = ss.getSheetByName(CONFIG.MEMO_SHEET_NAME);
  if (!sheet) return [];

  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return [];

  const lastCol = Math.max(sheet.getLastColumn(), 9);
  const data = sheet.getRange(2, 1, lastRow - 1, lastCol).getValues();
  const targetUserId = String(userId).trim();

  const filtered = data.filter(row => {
    if (!row[0]) return false;
    const type = row[1];
    const owner = row[2];
    const ownerStr = String(owner).trim();

    if (type === 'shared') return true;
    if (type === 'personal' && ownerStr === targetUserId) return true;
    return false;
  });

  filtered.sort((a, b) => new Date(b[5]) - new Date(a[5]));

  return filtered.map(row => {
    // ★ここを修正：大文字小文字を無視して判定
    const statusVal = (row.length > 8) ? String(row[8]).toUpperCase() : 'FALSE';
    return {
      id: row[0],
      type: row[1],
      userId: row[2],
      content: row[3],
      notifyTime: row[4] ? Utilities.formatDate(new Date(row[4]), 'Asia/Tokyo', 'yyyy-MM-dd HH:mm') : '',
      createdAt: row[5] ? Utilities.formatDate(new Date(row[5]), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm') : '',
      relatedUsers: (row[6] && String(row[6]) !== "") ? String(row[6]).split(',') : [],
      isFinished: (statusVal === 'TRUE')
    };
  });
}

/**
 * ★ID照合強化版：トリム処理で確実に保存する
 */
function toggleMemoStatus(memoId, userId, context = 'personal', cardId = null) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);

  let sheetName = CONFIG.MEMO_SHEET_NAME;
  let statusCol = 9;

  if (context === 'card') {
    sheetName = CONFIG.CARD_MEMO_SHEET_NAME;
    statusCol = 8;
  }

  const sheet = ss.getSheetByName(sheetName);
  if (sheet) {
    const data = sheet.getDataRange().getValues();
    const targetId = String(memoId).trim(); // 空白除去

    for (let i = 1; i < data.length; i++) {
      // シート上のIDもString化＆Trimして比較
      if (String(data[i][0]).trim() === targetId) {
        const rowNum = i + 1;
        const currentValRaw = (data[i].length >= statusCol) ? data[i][statusCol - 1] : 'FALSE';
        const currentVal = String(currentValRaw).toUpperCase();
        const newStatus = (currentVal === 'TRUE') ? 'FALSE' : 'TRUE';

        sheet.getRange(rowNum, statusCol).setValue(newStatus);
        SpreadsheetApp.flush(); // 即座に確定
        break;
      }
    }
  }
  // 返り値はクライアント側で無視されますが、エラーがないよう返しておきます
  return [];
}

/**
 * ★修正：メモ保存（Trello同期＆ID保存版）
 */
function addMemo(memoData) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  let sheet;
  let isCardMemo = (memoData.type === 'card');
  const id = Utilities.getUuid();
  const now = new Date();
  const cleanUserId = String(memoData.userId).trim();
  const relatedUsersStr = memoData.relatedUsers ? memoData.relatedUsers.join(',') : '';

  let trelloCommentId = ''; // ★追加：TrelloのコメントID保存用

  // ■ Trello同期処理
  if (isCardMemo && memoData.targetId) {
    try {
      const commentText = `【${cleanUserId}からのメモ】\n${memoData.content}`;
      // ★変更：投稿したコメントのIDを受け取る
      trelloCommentId = postTrelloComment(memoData.targetId, commentText);
    } catch (e) {
      console.error("Trello Comment Sync Error: " + e.message);
    }
  }

  // ■ 保存実行
  if (isCardMemo) {
    // 【カードメモの場合】
    sheet = ss.getSheetByName(CONFIG.CARD_MEMO_SHEET_NAME);
    if (!sheet) {
      sheet = ss.insertSheet(CONFIG.CARD_MEMO_SHEET_NAME);
      // ヘッダーに TrelloCommentID を追加
      sheet.appendRow(['ID', 'UserID', 'Content', 'Deadline', 'CreatedAt', 'CardID', 'RelatedUsers', 'IsFinished', 'TrelloCommentID']);
    }

    // ★修正：9列目(TrelloCommentID)まで確保する
    if (sheet.getMaxColumns() < 9) {
      sheet.insertColumnsAfter(sheet.getMaxColumns(), 9 - sheet.getMaxColumns());
    }

    const cardId = memoData.targetId ? String(memoData.targetId).trim() : '';

    sheet.appendRow([
      id,
      cleanUserId,
      memoData.content,
      memoData.notifyTime || '',
      now,
      cardId,
      relatedUsersStr,
      'FALSE',
      trelloCommentId // ★追加：9列目に保存
    ]);
    SpreadsheetApp.flush();
    return getCardMemos(cardId);

  } else {
    // 【個人/共有メモの場合】（既存のまま）
    sheet = ss.getSheetByName(CONFIG.MEMO_SHEET_NAME);
    if (!sheet) {
      sheet = ss.insertSheet(CONFIG.MEMO_SHEET_NAME);
      sheet.appendRow(['ID', 'Type', 'UserID', 'Content', 'NotifyTime', 'CreatedAt', 'RelatedUsers', 'TargetID', 'IsFinished']);
    }

    if (sheet.getMaxColumns() < 9) {
      sheet.insertColumnsAfter(sheet.getMaxColumns(), 9 - sheet.getMaxColumns());
    }

    sheet.appendRow([
      id,
      memoData.type,
      cleanUserId,
      memoData.content,
      memoData.notifyTime || '',
      now,
      relatedUsersStr,
      '',
      'FALSE'
    ]);
    SpreadsheetApp.flush();
    return getMemos(cleanUserId);
  }
}

/**
 * ★修正：Trelloカードにコメントを追加し、IDを返す
 */
function postTrelloComment(cardId, text) {
  const url = `https://api.trello.com/1/cards/${cardId}/actions/comments?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}`;

  const payload = { text: text };
  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(url, options);
  if (response.getResponseCode() !== 200) {
    throw new Error('Trello Comment Error: ' + response.getContentText());
  }

  // ★追加：レスポンスからIDを抽出して返す
  const json = JSON.parse(response.getContentText());
  return json.id;
}

/**
 * ★新規追加：Trelloコメントを削除する
 */
function deleteTrelloComment(commentId) {
  if (!commentId) return;

  // Trelloのコメント削除API (Action IDを指定)
  const url = `https://api.trello.com/1/actions/${commentId}?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}`;
  const options = {
    method: 'delete',
    muteHttpExceptions: true
  };

  UrlFetchApp.fetch(url, options);
  // 削除成功・失敗にかかわらずエラーは投げない（既に消えている場合などを考慮）
}

/**
 * ★新規追加：Trelloカードの説明(Description)を更新する
 */
function updateTrelloDescription(cardId, description) {
  try {
    const url = `https://api.trello.com/1/cards/${cardId}?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}`;

    const payload = {
      desc: description
    };

    const options = {
      method: 'put',
      contentType: 'application/json',
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    };

    const response = UrlFetchApp.fetch(url, options);

    if (response.getResponseCode() !== 200) {
      throw new Error('Trello Description Update Error: ' + response.getContentText());
    }

    return { success: true };
  } catch (e) {
    return { success: false, error: e.message };
  }
}

/**
 * ★修正版：カードメモ取得（Trelloコメント同期版）
 * シートのメモと、Trello上のコメントをマージして返します
 */
function getCardMemos(cardId) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  const sheet = ss.getSheetByName(CONFIG.CARD_MEMO_SHEET_NAME);

  let localMemos = [];
  const localCommentIds = new Set(); // 重複排除用

  // 1. スプレッドシートから保存済みメモを取得
  if (sheet && sheet.getLastRow() > 1) {
    // 9列目(TrelloCommentID)まで取得
    const lastCol = Math.max(sheet.getLastColumn(), 9);
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, lastCol).getValues();
    const targetCardId = String(cardId).trim();

    const filtered = data.filter(row => {
      const rowCardId = String(row[5] || "").trim();
      return rowCardId === targetCardId;
    });

    localMemos = filtered.map(row => {
      const statusVal = (row.length > 7) ? String(row[7]).toUpperCase() : 'FALSE';
      const trelloCommentId = (row.length > 8) ? String(row[8]) : "";

      if (trelloCommentId) localCommentIds.add(trelloCommentId);

      return {
        id: row[0],
        userId: row[1],
        content: row[2],
        deadline: row[3] ? Utilities.formatDate(new Date(row[3]), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm') : '',
        createdAt: row[4] ? Utilities.formatDate(new Date(row[4]), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm') : '',
        type: 'card',
        relatedUsers: (row[6] && String(row[6]) !== "") ? String(row[6]).split(',') : [],
        isFinished: (statusVal === 'TRUE'),
        trelloCommentId: trelloCommentId,
        isTrelloOnly: false // シートにあるデータ
      };
    });
  }

  // 2. Trelloから直接コメントを取得（API）
  let trelloMemos = [];
  try {
    const url = `https://api.trello.com/1/cards/${cardId}/actions?filter=commentCard&key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}&limit=50`;
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });

    if (response.getResponseCode() === 200) {
      const actions = JSON.parse(response.getContentText());

      // シートに保存されていないコメントのみを抽出
      trelloMemos = actions.filter(action => !localCommentIds.has(action.id)).map(action => {
        const d = new Date(action.date);
        const formattedDate = Utilities.formatDate(d, 'Asia/Tokyo', 'yyyy/MM/dd HH:mm');

        return {
          id: action.id, // TrelloのActionIDをそのままIDとして使用
          userId: action.memberCreator.fullName + " (Trello)", // Trelloユーザー名
          content: action.data.text,
          deadline: '',
          createdAt: formattedDate,
          type: 'card',
          relatedUsers: [],
          isFinished: false, // Trelloコメントはデフォルトで未完了扱い
          trelloCommentId: action.id,
          isTrelloOnly: true // ★重要：Trelloのみに存在するデータフラグ
        };
      });
    }
  } catch (e) {
    console.error("Trello Fetch Error: " + e.message);
    // エラーでもローカルデータは返す
  }

  // 3. マージしてソート（作成日順）
  const result = [...localMemos, ...trelloMemos];
  result.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

  return result;
}

/**
 * ★修正版：メモ削除（Trello直接削除対応）
 * シートになくてもTrelloIDであれば削除を試みる
 */
function deleteMemo(memoId, userId, currentContext = 'personal', currentCardId = null) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);

  let sheetName = CONFIG.MEMO_SHEET_NAME;
  let isCardMemo = false;

  if (currentContext === 'card') {
    sheetName = CONFIG.CARD_MEMO_SHEET_NAME;
    isCardMemo = true;
  }

  const sheet = ss.getSheetByName(sheetName);
  let deletedFromSheet = false;

  // 1. まずシートから探して削除を試みる
  if (sheet) {
    const data = sheet.getDataRange().getValues();
    const targetId = String(memoId).trim();
    let rowToDelete = -1;
    let trelloCommentId = "";

    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]).trim() === targetId) {
        rowToDelete = i + 1;
        if (isCardMemo && data[i].length > 8) {
          trelloCommentId = String(data[i][8]);
        }
        break;
      }
    }

    if (rowToDelete !== -1) {
      sheet.deleteRow(rowToDelete);
      SpreadsheetApp.flush();
      deletedFromSheet = true;

      // 紐付いているTrelloコメントも削除
      if (isCardMemo && trelloCommentId) {
        try { deleteTrelloComment(trelloCommentId); } catch (e) { console.error(e); }
      }
    }
  }

  // 2. シートになかった場合、かつカードメモの場合、直接Trelloコメントとしての削除を試みる
  // (getCardMemosで取得した "isTrelloOnly" なアイテムの場合、IDはTrelloのActionIDそのものになっている)
  if (!deletedFromSheet && isCardMemo) {
    try {
      // memoId自体がTrelloのActionIDである可能性が高い
      deleteTrelloComment(memoId);
    } catch (e) {
      console.error("Direct Trello Delete Error: " + e.message);
    }
  }

  // 削除後のデータを返す
  if (currentContext === 'card' && currentCardId) {
    return getCardMemos(currentCardId);
  }
  return getMemos(userId);
}

/**
 * ★新規追加：期限切れメモがあるカードIDのリストだけを返す（軽量版）
 * 30分ごとの定期チェック用
 */
function getOverdueMemoCardIds() {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  const sheet = ss.getSheetByName(CONFIG.CARD_MEMO_SHEET_NAME);
  const overdueIds = new Set();

  if (!sheet || sheet.getLastRow() <= 1) return [];

  // 必要な列（期限とカードIDと完了フラグ）だけ取得して高速化
  // 4列目:Deadline, 6列目:CardID, 8列目:IsFinished
  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 8).getValues();
  const now = new Date();

  data.forEach(row => {
    const deadlineStr = row[3];
    const cardId = String(row[5]).trim();
    const isFinished = String(row[7]).toUpperCase() === 'TRUE';

    if (cardId && !isFinished && deadlineStr) {
      const deadline = new Date(deadlineStr);
      if (deadline < now) {
        overdueIds.add(cardId);
      }
    }
  });

  return Array.from(overdueIds);
}

/* =========================================
   ★追加：ゲームデータ管理用（競馬・所持金・ガチャ）
   ========================================= */

/**
 * ゲームデータを取得する
 */
function getGameData(userId) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  let sheet = ss.getSheetByName(CONFIG.GAME_SHEET_NAME);
  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.GAME_SHEET_NAME);
    sheet.appendRow(['UserID', 'DataJSON', 'UpdatedAt']);
  }

  const data = sheet.getDataRange().getValues();
  const targetId = String(userId).trim();

  // ユーザーIDが一致する行を探す
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]).trim() === targetId) {
      return data[i][1]; // JSON文字列を返す
    }
  }
  return null; // データなし
}

/**
 * ゲームデータを保存する
 */
function saveGameData(userId, jsonStr) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  let sheet = ss.getSheetByName(CONFIG.GAME_SHEET_NAME);
  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.GAME_SHEET_NAME);
    sheet.appendRow(['UserID', 'DataJSON', 'UpdatedAt']);
  }

  const data = sheet.getDataRange().getValues();
  const targetId = String(userId).trim();
  const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');

  // 既存データがあれば更新
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]).trim() === targetId) {
      sheet.getRange(i + 1, 2).setValue(jsonStr);
      sheet.getRange(i + 1, 3).setValue(now);
      return { success: true };
    }
  }

  // 新規作成
  sheet.appendRow([targetId, jsonStr, now]);
  return { success: true };
}

/**
 * ★修正：ランキング用に全ユーザーのゲームデータを取得
 */
function getAllGameData() {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  const sheet = ss.getSheetByName(CONFIG.GAME_SHEET_NAME);

  if (!sheet || sheet.getLastRow() <= 1) return [];

  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 2).getValues();

  const results = data.map(row => {
    try {
      const userId = String(row[0]);
      const json = JSON.parse(row[1]);
      return {
        userId: userId,
        xp: json.xp || 0,
        level: json.level || 1,
        // ★修正：settings全体を返すように変更（装飾IDが必要なため）
        settings: json.settings || {}
      };
    } catch (e) {
      return null;
    }
  }).filter(item => item !== null);

  // ソート：レベルが高い順、同じならXPが高い順
  results.sort((a, b) => {
    if (b.level !== a.level) {
      return b.level - a.level;
    }
    return b.xp - a.xp;
  });

  return results;
}

/**
 * ★新規追加：Trelloのカスタムフィールド（リスト形式）を更新する関数
 * @param {string} cardId - カードID
 * @param {string} customFieldId - カスタムフィールドのID
 * @param {string|null} targetText - 選択したい値のテキスト（例: "1", "50"）。削除時はnull
 */
function updateTrelloListCustomField(cardId, customFieldId, targetText) {
  // 1. 設定値をクリアする場合
  if (targetText === null || targetText === "") {
    const clearPayload = { value: "" }; // クリア
    sendTrelloCustomFieldRequest(cardId, customFieldId, clearPayload);
    return;
  }

  // 2. Trelloからそのカスタムフィールドの情報を取得して、選択肢(Options)のリストを得る
  // (毎回取得するのはAPI呼び出しが増えますが、IDが変わっても対応できる安全な方法です)
  const fieldUrl = `https://api.trello.com/1/customFields/${customFieldId}?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}`;
  const fieldResponse = UrlFetchApp.fetch(fieldUrl, { method: 'get', muteHttpExceptions: true });

  if (fieldResponse.getResponseCode() !== 200) {
    throw new Error('Custom Field Get Error: ' + fieldResponse.getContentText());
  }

  const fieldData = JSON.parse(fieldResponse.getContentText());
  const options = fieldData.options || [];

  // 3. 入力されたテキスト（例 "5"）と一致する選択肢を探す
  // targetText と option.value.text が一致するものを探す
  const matchedOption = options.find(opt => opt.value.text == targetText);

  if (!matchedOption) {
    // リストにない数値（例: "99"など）が入力された場合はエラーにするか、無視するか
    // ここではログを出して終了（Trelloは更新しない）とします
    Logger.log(`Trello更新スキップ: 選択肢 "${targetText}" はTrelloのリスト定義に存在しません。`);
    return;
  }

  // 4. 見つかった選択肢のID (idValue) をセットして更新リクエストを送る
  const payload = { idValue: matchedOption.id };
  sendTrelloCustomFieldRequest(cardId, customFieldId, payload);
}

/**
 * 共通：TrelloへのPUTリクエスト送信ヘルパー
 */
function sendTrelloCustomFieldRequest(cardId, customFieldId, payload) {
  const url = `https://api.trello.com/1/cards/${cardId}/customField/${customFieldId}/item?key=${CONFIG.API_KEY}&token=${CONFIG.API_TOKEN}`;
  const options = {
    method: 'put',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };
  const response = UrlFetchApp.fetch(url, options);
  if (response.getResponseCode() !== 200) {
    throw new Error('Update Request Error: ' + response.getContentText());
  }
}

/* =========================================
   ★追加：Keibaデータ管理用（KeibaHistoryシート統合版）
   ========================================= */

// シート名の定義（トップレベルに移動）
const KEIBA_HISTORY_SHEET_NAME = 'Keibakekka'; // ★変更: Keibakekka
const KEIBA_RECORD_SHEET_NAME = 'Keiba-kiroku';

/** 1. KeibaHistoryシートを取得（なければ作成） */
function getKeibaSheet_() {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  // シート名を統一
  let sheet = ss.getSheetByName(KEIBA_HISTORY_SHEET_NAME);
  if (!sheet) {
    sheet = ss.insertSheet(KEIBA_HISTORY_SHEET_NAME);
    // スキーマ定義: [RaceID, ResultJson, AllBetsJson, UpdatedAt, 1st, 2nd, 3rd]
    sheet.appendRow(['RaceID', 'ResultJson', 'AllBetsJson', 'UpdatedAt', '1st', '2nd', '3rd']);
  }
  return sheet;
}

/** 2. 投票を記録する */
function recordKeibaBet(raceId, userId, betData) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(10000);
    const sheet = getKeibaSheet_();
    const data = sheet.getDataRange().getValues();
    const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');

    let rowIndex = -1;
    let bets = [];

    // 既存のレース行を探す
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === String(raceId)) {
        rowIndex = i + 1;
        bets = data[i][2] ? JSON.parse(data[i][2]) : [];
        break;
      }
    }

    bets.push({ user: userId, ...betData });
    const betsJson = JSON.stringify(bets);

    if (rowIndex !== -1) {
      sheet.getRange(rowIndex, 3).setValue(betsJson);
      sheet.getRange(rowIndex, 4).setValue(now);
    } else {
      // 新規行: ResultJsonは空、Betsはあり
      sheet.appendRow([raceId, '', betsJson, now, '', '', '']);
    }
    return { success: true };
  } catch (e) {
    return { error: e.message };
  } finally {
    lock.releaseLock();
  }
}

const RACE_SCHEDULE = [
  { h: 9, m: 55 }, { h: 10, m: 55 }, { h: 11, m: 55 }, { h: 12, m: 30 },
  { h: 13, m: 55 }, { h: 14, m: 55 }, { h: 15, m: 55 }, { h: 16, m: 55 }, { h: 17, m: 55 }
];
const ALL_HORSE_IDS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

/** 4. 当日の結果一覧を取得（未生成の過去レースがあれば生成する） */
function getTodayPastResults() {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);

  // A. 過去のレースで結果がないものを補完する
  const now = new Date();
  const currentHour = now.getHours();
  const currentMin = now.getMinutes();
  const currentTimeVal = currentHour * 60 + currentMin;

  const y = now.getFullYear();
  const m = ('0' + (now.getMonth() + 1)).slice(-2);
  const d = ('0' + now.getDate()).slice(-2);
  const todayDateStr = `${y}${m}${d}`; // YYYYMMDD

  RACE_SCHEDULE.forEach(race => {
    const raceTimeVal = race.h * 60 + race.m;
    // 現在時刻より前のレース（発走済み）
    if (currentTimeVal >= raceTimeVal + 5) { // 5分バッファ
      const hh = ('0' + race.h).slice(-2);
      const mm = ('0' + race.m).slice(-2);
      const raceId = `${todayDateStr}_${hh}${mm}`;

      // 結果生成 (既に存在すれば何もしない、なければ生成して保存)
      ensureRaceResult(raceId, ALL_HORSE_IDS);
    }
  });

  // B. シートから結果を取得して返す
  const sheet = getKeibaSheet_();
  const data = sheet.getDataRange().getValues();
  // 今日の日付文字列 (YYYYMMDD形式)
  const todayPrefix = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyyMMdd');

  const results = [];
  for (let i = 1; i < data.length; i++) {
    const raceId = String(data[i][0]);
    const resultJson = data[i][1];
    const betsJson = data[i][2];

    // 今日の日付を含み、かつ結果(resultJson)が入っているもの
    if (raceId.includes(todayPrefix) && resultJson && resultJson !== "") {
      try {
        let rawResult = JSON.parse(resultJson);
        let normalizedResult = [];

        if (Array.isArray(rawResult)) {
          normalizedResult = rawResult;
        } else if (rawResult.first) {
          // 旧形式(Object)の場合の互換対応
          normalizedResult = [rawResult.first, rawResult.second, rawResult.third];
        }

        results.push({
          raceId: raceId,
          result: normalizedResult,
          bets: betsJson ? JSON.parse(betsJson) : []
        });
      } catch (e) {
        console.error("JSON Parse Error in getTodayPastResults: " + e.message);
      }
    }
  }
  return results;
}

/**
 * 指定したレースIDの投票データを取得する
 * （みんなの投票リスト表示用）
 */
function getBetsForRace(raceId) {
  const sheet = getKeibaSheet_();
  const data = sheet.getDataRange().getValues();

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]) === String(raceId)) {
      const betsJson = data[i][2];
      return betsJson ? JSON.parse(betsJson) : [];
    }
  }
  return [];
}

function shuffleArray_(array) {
  const newArray = array.slice();
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

/* =========================================
   ★追加・修正：所持金ランキング機能
   ========================================= */

/**
 * 全ユーザーの所持金を集計してランキング更新
 */
/**
 * 全ユーザーの所持金を集計してランキング更新 (Keiba-kiroku から集計)
 */
function updateMoneyRanking_() {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);

  // 1. Keiba-kiroku から集計
  const sheetName = (typeof KEIBA_RECORD_SHEET_NAME !== 'undefined') ? KEIBA_RECORD_SHEET_NAME : 'Keiba-kiroku';
  const recordSheet = ss.getSheetByName(sheetName);
  if (!recordSheet) return;

  const data = recordSheet.getDataRange().getValues();
  // data format: [Timestamp, UserID, Type, Amount, Description, BalanceAfter]

  const balances = {};
  for (let i = 1; i < data.length; i++) {
    const userId = String(data[i][1]).trim();
    if (!userId) continue;

    // 最新のBalanceAfterを採用する方式か、Amountを積み上げる方式か
    // recordTransaction_ で BalanceAfter を記録しているので、ユーザーごとの最後の行の BalanceAfter が最新残高
    // しかし行の順番が保証されない場合を考慮し、マップで最新を保持するのが安全
    // ここでは単純に Amount の総和を取るのではなく、
    // 「そのユーザーの最後の行の BalanceAfter」を取得するほうが整合性が高い
    // ただし recordTransaction_ の実装を見ると、毎回 currentBalance を再計算して追記しているので、
    // BalanceAfter は信頼できる。

    const balance = Number(data[i][5]);
    if (!isNaN(balance)) {
      balances[userId] = balance; // 上書きしていく（下にある行ほど新しい前提）
    }
  }

  const ranking = Object.keys(balances).map(u => ({
    user: u,
    money: balances[u]
  }));
  ranking.sort((a, b) => b.money - a.money);

  // 2. KeibaHistoryシートにスナップショット保存
  const keibaSheet = getKeibaSheet_();
  const keibaData = keibaSheet.getDataRange().getValues();
  const targetId = "LATEST_MONEY_RANKING";
  const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');
  const jsonStr = JSON.stringify(ranking);

  let rowIndex = -1;
  for (let i = 1; i < keibaData.length; i++) {
    if (String(keibaData[i][0]) === targetId) {
      rowIndex = i + 1;
      break;
    }
  }

  if (rowIndex !== -1) {
    keibaSheet.getRange(rowIndex, 2).setValue(jsonStr);
    keibaSheet.getRange(rowIndex, 4).setValue(now);
  } else {
    keibaSheet.appendRow([targetId, jsonStr, '[]', now, '', '', '']);
  }

  return ranking; // ★追加：計算結果を返す
}

/**
 * ランキング取得
 */
/**
 * ランキング取得 (スナップショットから読み込み)
 * これにより高速化とタイムアウト回避を図る
 */
function getMoneyRanking() {
  const sheet = getKeibaSheet_(); // KeibaHistory
  const data = sheet.getDataRange().getValues();
  const targetId = "LATEST_MONEY_RANKING";

  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]) === targetId) {
      const json = data[i][1];
      if (json && json !== "") {
        try {
          return JSON.parse(json);
        } catch (e) {
          console.error("JSON Parse Error in getMoneyRanking: " + e.message);
        }
      }
    }
  }

  // スナップショットがない場合、またはパースエラーの場合は再計算してその結果を返す
  return updateMoneyRanking_();
}

/* ----- gas.gs ----- */

/* =========================================
   ★修正版：レース履歴・所持金・投票の統合管理
   ========================================= */

// シート名の定義: 削除 (トップレベルに移動済み)

/* =========================================
   ★追加：ガチャ記録用
   ========================================= */
function recordGachaItem(userId, item) {
  const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
  let sheet = ss.getSheetByName("Gacha");
  if (!sheet) {
    sheet = ss.insertSheet("Gacha");
    sheet.appendRow(['Timestamp', 'UserID', 'ItemID', 'ItemName']);
  }
  const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');
  // item は {id:..., name:..., ...} のオブジェクトを想定
  sheet.appendRow([now, userId, item.id, item.name]);
}

/**
 * お金の取引を記録
 */
function transactMoney(userId, amount, type, desc) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(5000);
    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);

    // 1. 記録シートへの保存と残高計算
    const newBalance = recordTransaction_(ss, userId, amount, type, desc);

    // 2. GameDataへの同期
    updateGameDataMoney_(ss, userId, newBalance);

    // 3. ランキング更新
    updateMoneyRanking_();

    return newBalance;
  } catch (e) {
    throw e;
  } finally {
    lock.releaseLock();
  }
}

/* =========================================
   gas.gs 追記・確認用
   ========================================= */

/**
 * 投票とお金の支払いを一括で行う（安全な投票処理）
 */
function placeBetAtomic(raceId, userId, betData, totalCost) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(10000);
    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);

    // 1. 支払い
    const currentBalance = getWalletBalance_(ss, userId);
    if (currentBalance < totalCost) {
      throw new Error(`所持金が足りません (必要: ${totalCost}, 所持: ${currentBalance})`);
    }
    const newBalance = recordTransaction_(ss, userId, -totalCost, 'BET', `馬券購入: ${betData.desc}`);
    updateGameDataMoney_(ss, userId, newBalance);

    // 2. 投票記録 (KeibaHistoryシートへ)
    const keibaSheet = getKeibaSheet_();
    const data = keibaSheet.getDataRange().getValues();
    const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');

    let rowIndex = -1;
    let bets = [];

    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === String(raceId)) {
        rowIndex = i + 1;
        bets = data[i][2] ? JSON.parse(data[i][2]) : [];
        break;
      }
    }

    bets.push({ user: userId, ...betData, timestamp: now });
    const betsJson = JSON.stringify(bets);

    if (rowIndex !== -1) {
      keibaSheet.getRange(rowIndex, 3).setValue(betsJson);
      keibaSheet.getRange(rowIndex, 4).setValue(now);
    } else {
      keibaSheet.appendRow([raceId, '', betsJson, now, '', '', '']);
    }

    // 3. ランキング更新
    updateMoneyRanking_();

    return { success: true, newBalance: newBalance };

  } catch (e) {
    throw e;
  } finally {
    lock.releaseLock();
  }
}

/**
 * ★修正：レース結果確定処理（履歴保存＋ランキング更新）
 * 完全統合版: すべて KeibaHistory シートで完結させる
 */
function ensureRaceResult(raceId, allHorseIds) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(10000);
    const sheet = getKeibaSheet_(); // KeibaHistory
    const data = sheet.getDataRange().getValues();
    const now = Utilities.formatDate(new Date(), 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');

    let rowIndex = -1;
    let result = null;
    let bets = [];

    // 既存のレース行を探す
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === String(raceId)) {
        rowIndex = i + 1;
        if (data[i][1] && data[i][1] !== "") result = JSON.parse(data[i][1]); // ResultJson
        if (data[i][2] && data[i][2] !== "") bets = JSON.parse(data[i][2]);   // AllBetsJson
        break;
      }
    }

    // 結果がまだ生成されていない場合のみ生成
    if (!result) {
      // ランダムに順位決定
      const shuffled = [...allHorseIds].sort(() => Math.random() - 0.5);
      // 結果オブジェクト: 配列で保持する形に合わせて { resultOrder: [1st, 2nd, 3rd...] } 形式でもよいが
      // 既存UIが {first, second, third} を期待しているか確認...
      // `javascript.html` の `startRaceAnimation` 内では `response.resultOrder` (Array) を期待している。
      // また `finishRace` では配列の [0],[1],[2] を使用している。
      // よって Array形式で返すのが素直だが、ここではDB保存用にオブジェクトにするか？
      // javascript.html 2730行目: const resultOrder = response.resultOrder;
      // サーバーからの返却値は `{ resultOrder: [...], allBets: [...] }`

      // 保存用データ構造
      // ここではシャッフルされたID配列そのものを保持するのが最もシンプルだが、
      // 構成上 { first:..., second:..., third:... } としていた経緯があるので合わせる？
      // いや、javascript.htmlを見る限り、サーバーからは `resultOrder` (配列) が返ってくると期待している。

      // resultとして配列そのものを保存する形に変更（ResultJson = ["id1", "id2", "..."]）
      result = shuffled;

      const resultJson = JSON.stringify(result);

      if (rowIndex !== -1) {
        // 既存行あり（投票のみされていた場合など） -> 結果を追記
        sheet.getRange(rowIndex, 2).setValue(resultJson);
        sheet.getRange(rowIndex, 4).setValue(now);
        // Human Readable Columns
        sheet.getRange(rowIndex, 5).setValue(result[0]);
        sheet.getRange(rowIndex, 6).setValue(result[1]);
        sheet.getRange(rowIndex, 7).setValue(result[2]);
      } else {
        // 行なし（誰も投票していないがレース結果を確定させる場合）
        // appendRow([RaceID, ResultJson, AllBetsJson, UpdatedAt, 1st, 2nd, 3rd])
        sheet.appendRow([
          raceId,
          resultJson,
          '[]',
          now,
          result[0],
          result[1],
          result[2]
        ]);
        bets = [];
      }

      // ランキング更新
      updateMoneyRanking_();
    }

    // クライアントに返すデータ
    // javascript.html の期待: { resultOrder: [...], allBets: [...] }
    // 保存されている result (もしObject {first, second...} なら配列に変換が必要だが、上記で配列として保存した)
    // 万が一 Object形式で保存されていた場合の互換性維持
    let resultOrderArray = [];
    if (Array.isArray(result)) {
      resultOrderArray = result;
    } else if (result.first) {
      resultOrderArray = [result.first, result.second, result.third];
    }

    return { resultOrder: resultOrderArray, allBets: bets };
  } catch (e) {
    throw e;
  } finally {
    lock.releaseLock();
  }
}

/**
 * レースの配当を処理する（サーバーサイド検証・重複防止付き）
 */
function processRacePayout(userId, raceId) {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(10000)) throw new Error('Server busy');

  try {
    const ss = getKeibaSheet_();
    const historySheet = ss; // getKeibaSheet_ calls ensure... but returns sheet
    // Actually getKeibaSheet_ creates/gets "KeibaHistory" sheet.

    // 1. レース結果と投票データを取得
    const data = historySheet.getDataRange().getValues();
    let raceRow = null;
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === String(raceId)) { // raceId comparison
        raceRow = data[i];
        break;
      }
    }

    if (!raceRow) return { success: false, message: 'Race not found' };

    const resultJson = raceRow[1];
    const allBetsJson = raceRow[2];

    // まだ結果が出ていない場合
    if (!resultJson || resultJson === '[]') return { success: false, message: 'No result yet' };

    const results = JSON.parse(resultJson); // [1st, 2nd, 3rd]
    const allBets = JSON.parse(allBetsJson);
    const myBets = allBets.filter(b => b.userId === userId);

    if (myBets.length === 0) return { success: true, payout: 0, newBalance: getWalletBalance_(userId) };

    const r1 = results[0];
    const r2 = results[1];
    const r3 = results[2];

    // 2. 配当計算 (javascript.htmlのcheckWinと同じロジック)
    let totalWin = 0;

    // Odds calculations need horse data? 
    // Wait, the bet object contains the odds at the time of betting?
    // Let's check placeBetAtomic implementation. 
    // bets.push({userId, type, horses:[...], amount, ...});
    // It does NOT store odds usually. But wait, verify bet object structure.
    // In javascript.html placeBet: "bet = { type, horses: ..., amount, odds: ... }"
    // Yes, javascript.html sends { ...odds... }. checking placeBetAtomic.
    // placeBetAtomic receives `betData`.
    // So `bet` object HAS odds.

    myBets.forEach(bet => {
      let win = 0;
      // 単勝
      if (bet.type === 'tansho' && bet.horses[0] === r1) {
        win = Math.floor(bet.amount * bet.odds);
      }
      // 複勝 (1-3着)
      else if (bet.type === 'fukusho' && (bet.horses[0] === r1 || bet.horses[0] === r2 || bet.horses[0] === r3)) {
        // 複勝オッズは変動するが、簡易的に保存されたoddsを使う
        win = Math.floor(bet.amount * bet.odds);
      }
      // 馬連 (1,2着 順不同)
      else if (bet.type === 'umaren') {
        const h1 = bet.horses[0]; const h2 = bet.horses[1];
        if ((h1 === r1 && h2 === r2) || (h1 === r2 && h2 === r1)) {
          win = Math.floor(bet.amount * bet.odds);
        }
      }
      // 馬単 (1->2着 順序通り)
      else if (bet.type === 'umatan' && bet.horses[0] === r1 && bet.horses[1] === r2) {
        win = Math.floor(bet.amount * bet.odds);
      }
      // 3連複 (1,2,3着 順不同)
      else if (bet.type === 'sanrenpuku') {
        const s = new Set([r1, r2, r3]);
        if (s.has(bet.horses[0]) && s.has(bet.horses[1]) && s.has(bet.horses[2])) {
          win = Math.floor(bet.amount * bet.odds);
        }
      }
      // 3連単 (1->2->3着 順序通り)
      else if (bet.type === 'sanrentan' &&
        bet.horses[0] === r1 && bet.horses[1] === r2 && bet.horses[2] === r3) {
        win = Math.floor(bet.amount * bet.odds);
      }

      totalWin += win;
    });

    if (totalWin === 0) return { success: true, payout: 0, newBalance: getWalletBalance_(userId) };

    // 3. 重複チェック (KeibaRecordを検索)
    const recordSheet = ss.getParent().getSheetByName(KEIBA_RECORD_SHEET_NAME);
    const records = recordSheet.getDataRange().getValues();
    const payoutKey = 'レース払戻: ' + raceId;

    // Check if user already has this payout
    // records format: [Timestamp, UserID, Type, Amount, Description, Balance]
    for (let i = 1; i < records.length; i++) {
      if (String(records[i][1]) === userId && records[i][4] === payoutKey) {
        // Already paid
        return { success: true, payout: 0, message: 'Already paid', newBalance: getWalletBalance_(userId) };
      }
    }

    // 4. トランザクション記録
    recordTransaction_(ss.getParent(), userId, totalWin, 'PAYOUT', payoutKey);

    return {
      success: true,
      payout: totalWin,
      newBalance: getWalletBalance_(userId)
    };

  } catch (e) {
    return { success: false, message: e.message };
  } finally {
    lock.releaseLock();
  }
}

// --- 内部ヘルパー関数群 ---

function recordTransaction_(ss, userId, amount, type, desc) {
  let sheet = ss.getSheetByName(KEIBA_RECORD_SHEET_NAME);
  if (!sheet) {
    sheet = ss.insertSheet(KEIBA_RECORD_SHEET_NAME);
    sheet.appendRow(['Timestamp', 'UserID', 'Type', 'Amount', 'Description', 'BalanceAfter']);
  }

  const now = new Date();

  // 借金制限チェック
  if (type === 'LOAN') {
    const todayStr = Utilities.formatDate(now, 'Asia/Tokyo', 'yyyy/MM/dd');
    const data = sheet.getDataRange().getValues();
    let todayLoan = 0;
    for (let i = 1; i < data.length; i++) {
      if (data[i][0]) {
        const rowDateStr = Utilities.formatDate(new Date(data[i][0]), 'Asia/Tokyo', 'yyyy/MM/dd');
        if (rowDateStr === todayStr && String(data[i][1]) === userId && data[i][2] === 'LOAN') {
          todayLoan += Number(data[i][3]);
        }
      }
    }
    if (todayLoan + amount > 10000) {
      throw new Error(`本日の借入限度額を超えています (済: ${todayLoan}円 / 申請: ${amount}円)`);
    }
  }

  // 残高計算
  let currentBalance = 0;
  const allData = sheet.getDataRange().getValues();
  for (let i = 1; i < allData.length; i++) {
    if (String(allData[i][1]) === userId) {
      currentBalance += Number(allData[i][3]);
    }
  }
  const newBalance = currentBalance + amount;

  // 記録
  const timestamp = Utilities.formatDate(now, 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');
  sheet.appendRow([timestamp, userId, type, amount, desc, newBalance]);

  return newBalance;
}

function getWalletBalance_(ss, userId) {
  const sheet = ss.getSheetByName(KEIBA_RECORD_SHEET_NAME);
  if (!sheet) return 0;
  const data = sheet.getDataRange().getValues();
  let balance = 0;
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][1]) === userId) {
      balance += Number(data[i][3]);
    }
  }
  return balance;
}

function updateGameDataMoney_(ss, userId, newBalance) {
  let sheet = ss.getSheetByName(CONFIG.GAME_SHEET_NAME);
  if (!sheet) return;
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][0]) === userId) {
      let json = JSON.parse(data[i][1]);
      json.money = newBalance;
      sheet.getRange(i + 1, 2).setValue(JSON.stringify(json));
      break;
    }
  }
}

/**
 * ランキング更新の強化版：GameDataではなくKeiba-kirokuの最新残高から集計する
 */
// function updateMoneyRanking_() : 削除 (トップレベルの最適化版を使用)
function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename)
    .getContent();
}
